---
title: 景区线路规划解题报告
date: 2017-10-08 18:32:46
tags: [algorithm,期望,记忆化搜索,解题报告]
---
# 题面
## 问题描述
游乐园被描述成一张n个点，m条边的无向图（无重边，无自环）。每个点代表一个娱乐项目，第i个娱乐项目需要耗费$c_i$分钟的时间，会让小y和妹子的开心度分别增加 $h1_i$,$h2_i$，他们俩初始的开心度都是 0 。每条边代表一条路，第i条边连接编号为$xi$,$y_i$的两个娱乐项目，从$x_i$走到$y_i$或者从$y_i$走到$x_i$耗费的时间都是$t_i$分钟。
<!--more-->
小y和妹子预计在游乐园里玩k分钟。最开始的时候，小y和妹子会等概率的随机选择一个娱乐项目开始玩，每玩完一个项目后，小y和妹子会等概率的随机选择一个可以从当前项目直达的且来得及玩的项目作为下一个项目。如果玩完一个项目后周围没有可以直达的且来得及玩的项目，小y和妹子就会提前结束游玩。 请你分别计算小y和妹子在游玩结束后开心度的期望。
## 输入数据
第一行给出三个空格隔开的整数，分别表示 n,m,k;
接下来的 n 行，每行三个空格隔开的整数，分别表示$c_i$,$h1_i$,$h2_i$;
接下来的 m 行，每行三个空格隔开的整数，分别表示$x_i$,$y_i$,$t_i$;
## 输出数据
两个用空格隔开的实数，分表表示小 y 和妹子开心度的期望，精确到小数点后 5 位。
## 输入样例
```
5 4 60
25 12 83
30 38 90
16 13 70
22 15 63
50 72 18
2 1 7
3 1 7
4 3 1
5 3 10
```
## 输出样例
```
39.20000 114.40000
```
## 数据范围
$0<n\leq100$
$1×60≤k\leq8×60$
$10\leq c(i)\leq60$
$0<h1(i),h2(i)\leq100$
$0<ti\leq150$

## 题目来源
美团 CodeM 初赛 Round B LiberOJ6178

# 题解
## 知识需求
+ 数学期望
+ 记忆化搜索。
## 关于数学期望
数学期望是试验中每次可能结果的概率乘以其结果的总和
好的讲完了#滑稽
还不懂的话。。见→ [数学期望](https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B/5362790?fr=aladdin)
## 正文【emmmmmm】
首先因为是期望题，马上想到期望DP。（当然记忆化搜索也是一样的啦，这题写了记忆化dfs）。用一个结构体保存小y和妹子分别获得的开心度的期望。
```cpp
struct node
{
	double b,g;
}f[N][500];
```
首先知道，我们最终要求的期望是从每个点出发可能取得的开心度的和除以总的点的数量，那么首先枚举这n个点，分别开始做dfs向外拓展，
```cpp
node that;
for(int i=1; i<=n; i++)
	that=dfs(i,K-c[i]),ans.b+=that.b*1.0/n,ans.g+=that.g*1.0/n;
```
用node dfs(int u,int k)这个函数计算从u这个点出发，剩余时间k所能取得的期望。
这段代码及解析如下：
```cpp
node dfs(int u,int k)//u代表当前位置，k代表剩余时间
{
	if(vis[u][k])
		return f[u][k];//记忆化搜索标配
	vis[u][k]=1;//标记已访问的状态
	node& dp=f[u][k],now;//简化代码
	dp.b=h1[u],dp.g=h2[u];//初始化
	int cnt=0;
	for(int i=head[u]; i; i=nxt[i])
		if(k>=c[to[i]]+w[i]) cnt++;//统计从这个点开始能访问到的节点总数
		//定义能访问：剩余的时间足够走到那个节点并且玩完那个项目
	for(int i=head[u]; i; i=nxt[i])
	{
		int v=to[i];
		if(k<c[v]+w[i]) continue;//如果不能访问则查找下一个节点
		now=dfs(v,k-c[v]-w[i]),dp.b+=now.b*1.0/cnt,dp.g+=now.g*1.0/cnt;
		//计算走到那个节点之后所得的期望，并加到将要返回的答案中
	}
	return dp;//返回
}
```
于是乎dfs就打好了，之后只需要完善一些细节就行了。
## 后记
既然代码解析已经放在那里了相信各位大佬一定就能秒懂并且秒切了这道题orz
不过有疑问还是可以来找我= =。
